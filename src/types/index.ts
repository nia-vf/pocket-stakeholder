/**
 * Core types for pocket-stakeholder
 * Based on SPEC.md API Design and tech-lead-agent.md requirements
 */

/**
 * Input context for stakeholder interviews
 * Provides all relevant information about the feature being discussed
 */
export interface FeatureContext {
  /** Path to the specification file being analyzed */
  specPath: string;

  /** Parsed content of the specification */
  specContent: string;

  /** Extracted sections from the spec (overview, requirements, etc.) */
  parsedSpec: ParsedSpec;

  /** Project-level context (from CLAUDE.md, existing decisions) */
  projectContext: ProjectContext;

  /** Any previous interview results from other stakeholders */
  previousInterviews?: InterviewResult[];
}

/**
 * Structured representation of a parsed specification document
 */
export interface ParsedSpec {
  /** Document title */
  title: string;

  /** Brief overview/summary */
  overview?: string;

  /** List of features or requirements */
  features?: SpecFeature[];

  /** Technical requirements or constraints */
  requirements?: SpecRequirement[];

  /** Technical architecture details */
  technicalArchitecture?: string;

  /** Raw sections that couldn't be categorized */
  otherSections: Record<string, string>;
}

/**
 * A feature extracted from a specification
 */
export interface SpecFeature {
  name: string;
  description: string;
  priority?: 'P0' | 'P1' | 'P2' | 'P3';
}

/**
 * A requirement extracted from a specification
 */
export interface SpecRequirement {
  id: string;
  description: string;
  type: 'functional' | 'non-functional';
}

/**
 * Project-level context loaded from CLAUDE.md and existing decisions
 */
export interface ProjectContext {
  /** Contents of CLAUDE.md if present */
  claudeMd?: string;

  /** Existing ADRs/decisions */
  existingDecisions: ExistingDecision[];

  /** Project root path */
  projectRoot: string;
}

/**
 * Reference to an existing decision document
 */
export interface ExistingDecision {
  id: string;
  title: string;
  status: 'Proposed' | 'Accepted' | 'Deprecated' | 'Superseded';
  path: string;
  summary?: string;
}

/**
 * Result of a stakeholder interview session
 */
export interface InterviewResult {
  /** Which stakeholder conducted the interview */
  stakeholderRole: StakeholderRole;

  /** Questions asked and answers received */
  exchanges: InterviewExchange[];

  /** Key insights identified during the interview */
  insights: string[];

  /** Decisions identified that need documentation */
  identifiedDecisions: IdentifiedDecision[];

  /** Areas flagged as ambiguous or needing clarification */
  ambiguities: Ambiguity[];

  /** Timestamp of interview completion */
  completedAt: Date;
}

/**
 * A single question-answer exchange in an interview
 */
export interface InterviewExchange {
  question: string;
  answer: string;
  followUpTriggered: boolean;
}

/**
 * A decision identified during analysis or interview
 */
export interface IdentifiedDecision {
  /** Brief title for the decision */
  title: string;

  /** What type of decision this is */
  category: DecisionCategory;

  /** Description of the decision to be made */
  description: string;

  /** How clear/ambiguous the decision is (0-1, where 1 is clear) */
  clarityScore: number;

  /** Potential options if already identified */
  options?: string[];
}

/**
 * Categories of technical decisions
 */
export type DecisionCategory =
  | 'architecture'
  | 'library'
  | 'pattern'
  | 'integration'
  | 'data-model'
  | 'api-design'
  | 'security'
  | 'performance';

/**
 * An ambiguous area identified in the spec
 */
export interface Ambiguity {
  /** What is unclear */
  description: string;

  /** Where in the spec this ambiguity exists */
  location?: string;

  /** Suggested questions to resolve this */
  suggestedQuestions: string[];
}

/**
 * Recommendations generated by a stakeholder after analysis
 */
export interface Recommendations {
  /** Stakeholder making the recommendations */
  stakeholderRole: StakeholderRole;

  /** ADRs to be generated */
  adrs: ADRDraft[];

  /** General recommendations that don't warrant full ADRs */
  generalRecommendations: string[];

  /** Warnings or concerns to highlight */
  warnings: string[];
}

/**
 * Draft of an Architecture Decision Record
 */
export interface ADRDraft {
  /** Suggested title */
  title: string;

  /** Decision category */
  category: DecisionCategory;

  /** Context section content */
  context: string;

  /** The decision being made */
  decision: string;

  /** Consequences (positive and negative) */
  consequences: {
    positive: string[];
    negative: string[];
  };

  /** Alternatives that were considered */
  alternativesConsidered: AlternativeOption[];
}

/**
 * An alternative option considered for a decision
 */
export interface AlternativeOption {
  name: string;
  description: string;
  pros: string[];
  cons: string[];
  rejectionReason?: string;
}

/**
 * Supported stakeholder roles
 */
export type StakeholderRole = 'tech-lead' | 'qa' | 'ux';

/**
 * Configuration for a stakeholder agent
 */
export interface StakeholderConfig {
  role: StakeholderRole;
  /** API key for LLM (defaults to ANTHROPIC_API_KEY env var) */
  apiKey?: string;
  /** Model to use (defaults to claude-sonnet-4-20250514) */
  model?: string;
}

/**
 * User answers provided during an interview
 */
export interface UserAnswers {
  /** Map of question to answer */
  answers: Map<string, string>;
}

/**
 * Base interface that all stakeholder agents must implement
 * Per SPEC.md API Design
 */
export interface StakeholderAgent {
  /** The role this agent represents */
  role: StakeholderRole;

  /**
   * Conduct an interview with the user based on the feature context
   * @param context Feature context including spec and project info
   * @returns Interview results including insights and identified decisions
   */
  conductInterview(context: FeatureContext): Promise<InterviewResult>;

  /**
   * Generate recommendations based on interview answers
   * @param answers User's answers from the interview
   * @returns Recommendations including ADR drafts
   */
  generateRecommendations(answers: UserAnswers): Promise<Recommendations>;
}
